package com.av.urbanway.data.repository

import com.av.urbanway.data.model.*
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import java.time.LocalDateTime
import java.util.*

class ChatRepository {
    private val _messages = MutableStateFlow<List<ChatMessage>>(emptyList())
    val messages: StateFlow<List<ChatMessage>> = _messages.asStateFlow()

    fun addUserMessage(content: String) {
        val userMessage = ChatMessage(
            id = UUID.randomUUID().toString(),
            type = MessageType.USER,
            content = content,
            lastUpdated = LocalDateTime.now()
        )

        val currentMessages = _messages.value.toMutableList()
        currentMessages.add(userMessage)
        _messages.value = currentMessages
    }

    fun addAutogeneratedMessage(content: String, queryType: QueryType) {
        val autoMessage = ChatMessage(
            id = UUID.randomUUID().toString(),
            type = MessageType.AUTOGENERATED,
            content = content,
            queryType = queryType,
            lastUpdated = LocalDateTime.now()
        )

        val currentMessages = _messages.value.toMutableList()
        currentMessages.add(autoMessage)
        _messages.value = currentMessages
    }

    fun addBotMessage(
        content: String,
        queryType: QueryType,
        data: TransitData,
        isCompact: Boolean = false
    ) {
        val botMessage = ChatMessage(
            id = UUID.randomUUID().toString(),
            type = MessageType.BOT,
            content = content,
            queryType = queryType,
            data = data,
            isCompact = isCompact,
            lastUpdated = LocalDateTime.now()
        )

        val currentMessages = _messages.value.toMutableList()
        currentMessages.add(botMessage)
        _messages.value = currentMessages
    }

    fun compactAllPreviousMessages() {
        val currentMessages = _messages.value.toMutableList()

        // Make all messages compact except the last one
        for (i in 0 until currentMessages.size - 1) {
            if (currentMessages[i].type == MessageType.BOT) {
                currentMessages[i] = currentMessages[i].copy(isCompact = true)
            }
        }

        _messages.value = currentMessages
    }

    fun handleModalSelection(
        selectedItem: String,
        fromQueryType: QueryType,
        newData: TransitData
    ) {
        // First, compact all previous messages
        compactAllPreviousMessages()

        // Add autogenerated message for the selection
        val newQueryType = when (fromQueryType) {
            QueryType.NEARBY -> QueryType.ROUTEDETAIL
            QueryType.ROUTEDETAIL -> QueryType.STOPDETAIL
            QueryType.STOPDETAIL -> QueryType.NEARBY
            QueryType.JOURNEY -> QueryType.STOPDETAIL
        }

        addAutogeneratedMessage(selectedItem, newQueryType)

        // Add bot response with new data
        val botContent = when (newQueryType) {
            QueryType.ROUTEDETAIL -> {
                // For route detail, generate content based on actual data
                if (newData is TransitData.RouteDetailData) {
                    "Linea ${newData.route.name} ${newData.route.direction} - ${newData.stops.size} fermate"
                } else {
                    generateBotContent(selectedItem, newQueryType)
                }
            }
            else -> generateBotContent(selectedItem, newQueryType)
        }
        addBotMessage(botContent, newQueryType, newData)
    }

    private fun generateBotContent(selection: String, queryType: QueryType): String {
        return when (queryType) {
            QueryType.ROUTEDETAIL -> {
                // For route detail, we'll let the actual data determine the content
                // This will be overridden by the actual implementation
                "Ecco i dettagli per la $selection"
            }
            QueryType.STOPDETAIL -> "Informazioni sulla fermata $selection"
            QueryType.NEARBY -> "Prossimi arrivi vicino a $selection"
            QueryType.JOURNEY -> "Percorso per raggiungere $selection"
        }
    }

    fun clearMessages() {
        _messages.value = emptyList()
    }

    fun getMessageById(messageId: String): ChatMessage? {
        return _messages.value.find { it.id == messageId }
    }
}