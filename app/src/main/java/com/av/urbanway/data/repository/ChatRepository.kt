package com.av.urbanway.data.repository

import com.av.urbanway.data.model.*
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import java.time.LocalDateTime
import java.util.*

class ChatRepository {
    private val _messages = MutableStateFlow<List<ChatMessage>>(emptyList())
    val messages: StateFlow<List<ChatMessage>> = _messages.asStateFlow()

    fun addUserMessage(content: String) {
        val userMessage = ChatMessage(
            id = UUID.randomUUID().toString(),
            type = MessageType.USER,
            content = content,
            lastUpdated = LocalDateTime.now()
        )

        val currentMessages = _messages.value.toMutableList()
        currentMessages.add(userMessage)
        _messages.value = currentMessages
    }

    fun addAutogeneratedMessage(content: String, queryType: QueryType) {
        val autoMessage = ChatMessage(
            id = UUID.randomUUID().toString(),
            type = MessageType.AUTOGENERATED,
            content = content,
            queryType = queryType,
            lastUpdated = LocalDateTime.now()
        )

        val currentMessages = _messages.value.toMutableList()
        currentMessages.add(autoMessage)
        _messages.value = currentMessages
    }

    fun addBotMessage(
        content: String,
        queryType: QueryType,
        data: TransitData,
        isCompact: Boolean = false
    ) {
        val botMessage = ChatMessage(
            id = UUID.randomUUID().toString(),
            type = MessageType.BOT,
            content = content,
            queryType = queryType,
            data = data,
            isCompact = isCompact,
            lastUpdated = LocalDateTime.now()
        )

        val currentMessages = _messages.value.toMutableList()
        currentMessages.add(botMessage)
        _messages.value = currentMessages
    }

    fun compactAllPreviousMessages() {
        val currentMessages = _messages.value.toMutableList()

        if (currentMessages.isEmpty()) return

        // Find the last BOT message (current response)
        val lastBotIndex = currentMessages.indexOfLast { it.type == MessageType.BOT }
        if (lastBotIndex == -1) return // No BOT messages to compact

        // Check if there's an AUTOGENERATED message just before the last BOT (current interaction)
        val currentAutogeneratedIndex = if (lastBotIndex > 0 &&
            currentMessages[lastBotIndex - 1].type == MessageType.AUTOGENERATED) {
            lastBotIndex - 1
        } else {
            -1
        }

        val filteredMessages = mutableListOf<ChatMessage>()

        for (i in currentMessages.indices) {
            val message = currentMessages[i]

            when (message.type) {
                MessageType.USER -> {
                    // Keep ALL USER messages
                    filteredMessages.add(message)
                }
                MessageType.AUTOGENERATED -> {
                    if (i == currentAutogeneratedIndex) {
                        // Keep current AUTOGENERATED message (part of current conversation)
                        filteredMessages.add(message)
                    }
                    // Remove all previous AUTOGENERATED messages
                }
                MessageType.BOT -> {
                    if (i == lastBotIndex) {
                        // Keep current BOT message as-is (expanded)
                        filteredMessages.add(message)
                    } else {
                        // Only compact BOT messages that are currently expanded
                        if (!message.isCompact) {
                            filteredMessages.add(message.copy(isCompact = true))
                        } else {
                            // Keep already compact messages as-is
                            filteredMessages.add(message)
                        }
                    }
                }
            }
        }

        _messages.value = filteredMessages
    }

    fun handleModalSelection(
        selectedItem: String,
        fromQueryType: QueryType,
        newData: TransitData
    ) {
        // Add autogenerated message for the selection
        val newQueryType = when (fromQueryType) {
            QueryType.NEARBY -> QueryType.ROUTEDETAIL
            QueryType.ROUTEDETAIL -> QueryType.STOPDETAIL
            QueryType.STOPDETAIL -> QueryType.NEARBY
            QueryType.JOURNEY -> QueryType.STOPDETAIL
        }

        addAutogeneratedMessage(selectedItem, newQueryType)

        // Add bot response with new data
        val botContent = when (newQueryType) {
            QueryType.ROUTEDETAIL -> {
                // For route detail, generate content based on actual data
                if (newData is TransitData.RouteDetailData) {
                    "Linea ${newData.route.name} ${newData.route.direction} - ${newData.stops.size} fermate"
                } else {
                    generateBotContent(selectedItem, newQueryType)
                }
            }
            else -> generateBotContent(selectedItem, newQueryType)
        }
        addBotMessage(botContent, newQueryType, newData)

        // Compact all previous messages after adding the new BOT message
        compactAllPreviousMessages()
    }

    private fun generateBotContent(selection: String, queryType: QueryType): String {
        return when (queryType) {
            QueryType.ROUTEDETAIL -> {
                // For route detail, we'll let the actual data determine the content
                // This will be overridden by the actual implementation
                "Ecco i dettagli per la $selection"
            }
            QueryType.STOPDETAIL -> "Informazioni sulla fermata $selection"
            QueryType.NEARBY -> "Prossimi arrivi vicino a $selection"
            QueryType.JOURNEY -> "Percorso per raggiungere $selection"
        }
    }

    fun clearMessages() {
        _messages.value = emptyList()
    }

    fun getMessageById(messageId: String): ChatMessage? {
        return _messages.value.find { it.id == messageId }
    }
}