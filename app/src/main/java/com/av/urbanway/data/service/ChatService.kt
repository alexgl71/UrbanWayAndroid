package com.av.urbanway.data.service

import com.av.urbanway.data.model.QueryType
import com.av.urbanway.data.model.RouteSelection
import com.av.urbanway.data.parser.QueryParser
import com.av.urbanway.data.repository.ChatRepository
import java.time.LocalDateTime

class ChatService(
    private val chatRepository: ChatRepository,
    private val queryParser: QueryParser,
    private val dataService: HardcodedDataService
) {

    suspend fun handleUserInput(userInput: String) {
        // Step 1: Add user message
        chatRepository.addUserMessage(userInput)

        // Step 2: Parse the query
        val queryType = queryParser.parseUserInput(userInput)

        if (queryType == null) {
            // Handle unknown query
            handleUnknownQuery(userInput)
            return
        }

        // Step 3: Add autogenerated message
        val autogeneratedText = queryParser.generateAutogeneratedText(userInput, queryType)
        chatRepository.addAutogeneratedMessage(autogeneratedText, queryType)

        // Step 4: Get data and add bot response
        when (queryType) {
            QueryType.NEARBY -> handleNearbyQuery(userInput)
            QueryType.ROUTEDETAIL -> handleRouteDetailQuery(userInput)
            QueryType.STOPDETAIL -> handleStopDetailQuery(userInput)
            QueryType.JOURNEY -> handleJourneyQuery(userInput)
        }
    }

    private fun handleNearbyQuery(userInput: String) {
        val nearbyData = dataService.getNearbyArrivals()

        // Count unique routes from arrivals
        val uniqueRoutes = nearbyData.arrivals.map { it.routeName }.toSet().size
        val totalStops = nearbyData.stops.size

        val botResponse = "Da qui passano $uniqueRoutes linee e hai $totalStops fermate disponibili"

        // Compact all previous messages before adding new BOT message
        chatRepository.compactAllPreviousMessages()

        chatRepository.addBotMessage(
            content = botResponse,
            queryType = QueryType.NEARBY,
            data = nearbyData,
            isCompact = false
        )
    }

    private fun handleRouteDetailQuery(userInput: String) {
        // Extract route ID from the user input - for now we'll use a simple approach
        val routeId = extractRouteId(userInput)
        val routeDetailData = dataService.getRouteDetailData(routeId)

        val botResponse = "Linea ${routeDetailData.route.name} ${routeDetailData.route.direction} - ${routeDetailData.stops.size} fermate"

        // Compact all previous messages before adding new BOT message
        chatRepository.compactAllPreviousMessages()

        chatRepository.addBotMessage(
            content = botResponse,
            queryType = QueryType.ROUTEDETAIL,
            data = routeDetailData,
            isCompact = false
        )
    }

    private fun extractRouteId(userInput: String): String {
        // Simple extraction - look for numbers in the input
        val routeMatch = Regex("\\d+").find(userInput)
        return routeMatch?.value ?: "56" // Default to 56 for testing
    }

    private fun handleStopDetailQuery(userInput: String) {
        // TODO: Implement when you provide STOPDETAIL JSON
        val botResponse = queryParser.generateBotResponse(QueryType.STOPDETAIL, userInput)
        // For now, create empty data - will be replaced with real data later
    }

    private fun handleJourneyQuery(userInput: String) {
        // TODO: Implement when you provide JOURNEY JSON
        val botResponse = queryParser.generateBotResponse(QueryType.JOURNEY, userInput)
        // For now, create empty data - will be replaced with real data later
    }

    private fun handleUnknownQuery(userInput: String) {
        chatRepository.addBotMessage(
            content = "Non ho capito la tua richiesta. Prova a chiedere informazioni su arrivi, linee o percorsi.",
            queryType = QueryType.NEARBY, // Default fallback
            data = dataService.getNearbyArrivals(),
            isCompact = false
        )
    }

    fun handleModalSelection(routeSelection: RouteSelection, fromQueryType: QueryType) {
        when (fromQueryType) {
            QueryType.NEARBY -> {
                // User selected a route with full info: routeId, headsign, tripId
                // Get route detail data using the route ID
                val routeData = getRouteDetailData(routeSelection.routeId)

                // Generate autogenerated message using the display text
                val autogeneratedText = queryParser.generateAutogeneratedText(routeSelection.displayText, QueryType.ROUTEDETAIL)

                // Handle the modal selection with proper autogenerated text
                chatRepository.handleModalSelection(
                    selectedItem = autogeneratedText,
                    fromQueryType = QueryType.NEARBY,
                    newData = routeData
                )

                // TODO: Use routeSelection.headsign and routeSelection.tripId for specific route data
                // This allows for future implementation of trip-specific route details
            }
            else -> {
                // Handle other modal selections
            }
        }
    }

    private fun getRouteDetailData(routeId: String): com.av.urbanway.data.model.TransitData {
        return dataService.getRouteDetailData(routeId)
    }
}