# UrbanWay - Turin Public Transport Assistant

![Android CI](https://github.com/YOUR_USERNAME/UrbanWayAndroid/workflows/Android%20CI/badge.svg)
![Release](https://github.com/YOUR_USERNAME/UrbanWayAndroid/workflows/Release%20Build/badge.svg)

## Project Overview

UrbanWay is a **conversational Android app** for Turin's public transport system, built from scratch using modern Android development practices. The app provides an intelligent chat interface that helps users get real-time transport information through natural language queries.

## Architecture & Technology Stack

### Core Technologies
- **Language**: Kotlin
- **UI Framework**: Jetpack Compose (Material 3)
- **Architecture**: MVVM with Repository Pattern
- **Minimum SDK**: 24 (Android 7.0)
- **Target SDK**: 36 (Latest)

### Key Features Implemented

#### ðŸ¤– Conversational Interface - THE THREE-MESSAGE PATTERN
The app's **core innovation** is a sophisticated three-message conversation pattern:

**1. `USER` Message** - Natural language input
```
"Quali sono le linee che passano vicino a me?"
```

**2. `AUTOGENERATED` Message** - AI interpretation & confirmation
```
"Arrivi nelle vicinanze"
```
- Shows user what the app understood
- Generated by `QueryParser` with context-awareness
- Examples: "Linea 15", "Percorso per il centro cittÃ "

**3. `BOT` Message** - Data-rich interactive response
```
"Ho trovato 8 arrivi nelle vicinanze da 5 fermate" + TransitData
```
- Contains actual transit data (`TransitData` sealed classes)
- Interactive UI components (cards, buttons, modals)
- Can be `compact` (summary) or expanded (full details)

**Conversation Flow:**
```
User Input â†’ Parse Query Type â†’ Add AUTOGENERATED â†’ Fetch Data â†’ Add BOT Response
```

#### ðŸšŒ Transit Data Management
Comprehensive data models for Turin's transport system:

**Transport Types Supported:**
- Buses (`BUS`)
- Trams (`TRAM`)
- Metro (`METRO`)
- Trains (`TRAIN`)

**Query Types:**
- `NEARBY` - Find nearby stops and arrivals
- `ROUTEDETAIL` - Get specific route information
- `STOPDETAIL` - View stop details and passing routes
- `JOURNEY` - Plan trips between locations

#### ðŸ“Š Real-time Data Integration
- Live arrival times with real-time updates
- Route delays and status information
- Stop locations with coordinates
- Multi-modal transport planning

## Current Implementation Status

### âœ… Completed Components

#### Data Layer (`/data`)
- **Models** (`ChatModels.kt`): Complete data structures for chat messages, transit data, stops, routes, arrivals
- **Repository** (`ChatRepository.kt`): StateFlow-based message management with compacting and modal selection
- **Services**:
  - `ChatService.kt`: Orchestrates user interactions and data flow
  - `HardcodedDataService.kt`: Provides sample Turin transit data
- **Parser** (`QueryParser.kt`): Natural language processing for Italian queries

#### UI Layer (`/ui`)
- **Theme System**: Material 3 implementation with dynamic colors
- **MainActivity**: Basic Compose setup with welcome screen

### ðŸš§ In Development
- **Presentation Layer**: Chat UI components
- **Navigation**: Screen navigation system
- **API Integration**: Real Turin transit API connection

## Screenshot Analysis

From the provided screenshot, the intended UI shows:

1. **Header**: "Assistente UrbanWay" with chat conversation count
2. **Chat Interface**: Natural language input ("Quali sono le linee che passano vicino a me?")
3. **Response Cards**:
   - Location-based results (e.g., "Piazza Adriano")
   - Transit information ("15 linee e hai 14 fermate disponibili")
   - Action buttons ("Vedi i dettagli")
4. **Input Field**: Bottom text input for user queries
5. **Dark Theme**: Modern dark UI design

## Key Architectural Decisions

### 1. **Three-Message Conversation Pattern** ðŸ”„
**The fundamental UX innovation**: Every user query triggers exactly 3 messages:
- `USER` â†’ `AUTOGENERATED` â†’ `BOT`
- Creates transparency: users see what the app understood
- Enables progressive disclosure with context preservation

### 2. **Smart Message State Management**
```kotlin
// Message Compacting: Keep chat clean
compactAllPreviousMessages() // Makes BOT messages compact except current

// Modal Interactions: Seamless drilling down
handleModalSelection("Linea 15", QueryType.NEARBY) â†’ New conversation branch
```

### 3. **Query Type State Transitions**
Intelligent navigation between contexts:
```
NEARBY â†’ ROUTEDETAIL â†’ STOPDETAIL â†’ NEARBY (full circle)
JOURNEY â†’ STOPDETAIL (direct context switch)
```

### 4. **Natural Language Processing (Italian)**
`QueryParser` with context-aware interpretation:
- Route extraction: "linea 15" â†’ "Linea 15"
- Location detection: "centro" â†’ "Percorso per il centro cittÃ "
- Intent classification: "arrivi" â†’ `QueryType.NEARBY`

### 5. **Reactive UI with Compact/Expand States**
- `isCompact: false` â†’ Full interactive cards with buttons
- `isCompact: true` â†’ Summary view for chat history
- StateFlow-driven UI updates

## Sample Data (Piazza Adriano Area)

The app currently uses hardcoded Turin transit data around **Piazza Adriano**:

**Nearby Stops:**
- Fermata 595 - ADRIANO (Routes: 16CDU, 56U, 9U)
- Fermata 646 - ADRIANO (Routes: 16CSU, 56U, 9U)
- Fermata 3286 - FERRUCCI (Routes: 55U, 68U, 9U)
- Fermata 3287 - FERRUCCI (Routes: 55U, 68U, 9U)
- Fermata 1532 - CAVALLI (Route: 56U)

**Active Routes:**
- Line 16 (Circolare Destra/Sinistra)
- Lines 55, 56, 68, 9 (Various directions)

## Critical Implementation Notes for Development

### ðŸš¨ **MUST UNDERSTAND: The Three-Message Pattern**
When implementing UI components, remember:

1. **`USER` messages**: Simple chat bubbles with user input
2. **`AUTOGENERATED` messages**: System interpretation tags (like "Arrivi nelle vicinanze")
3. **`BOT` messages**: Complex interactive cards with:
   - Transit data rendering (`TransitData` sealed classes)
   - Action buttons that trigger `handleModalSelection()`
   - Compact/expanded states based on `isCompact` boolean

### ðŸ”„ **Message State Lifecycle**
```kotlin
// New query â†’ Previous BOT messages become compact
// Modal selection â†’ New AUTOGENERATED + BOT pair added
// Query type transitions follow predefined flow
```

### ðŸŽ¯ **BOT Message Template System - THREE TEMPLATES PER QueryType**

#### **Template States & Compacting Logic:**
```kotlin
// Default: isCompact = false (expanded card)
// When new BOT message added:
compactAllPreviousMessages() {
    - All previous BOT messages: isCompact = true (compact version)
    - All previous AUTOGENERATED messages: REMOVED from UI
    - Current BOT message: isCompact = false (expanded + button)
}
```

#### **Three Templates for Each QueryType:**

**For NEARBY, ROUTEDETAIL, STOPDETAIL, JOURNEY - each needs:**

**1. Compact Template** (`isCompact = true`)
```
Brief summary text only - no interactions
```

**2. Expanded Template** (`isCompact = false` - shown in screenshot)
```
ðŸŸ¢ Piazza Adriano                    [Green location pin]
Da qui passano 15 linee e hai 14
fermate disponibili.

           [Vedi i dettagli]         [Centered button]
```

**3. Modal Fullscreen Template** (triggered by "Vedi i dettagli")
```
Full-screen overlay with detailed TransitData
Layout varies by QueryType and data content

STANDARD MODAL STRUCTURE:
â”œâ”€â”€ Header (title + close X button)
â”œâ”€â”€ Content (scrollable LazyColumn)
â””â”€â”€ Bottom Toolbar (map + close buttons, centered)
```

#### **Total UI Components Needed: 12 Templates + Shared Components**
- **Chat Cards**: `NearbyBotCard`, `RouteDetailBotCard`, `StopDetailBotCard`, `JourneyBotCard` (each with compact/expanded states)
- **Fullscreen Modals**: `NearbyModal`, `RouteDetailModal`, `StopDetailModal`, `JourneyModal`
- **Shared Components**:
  - `ModalBottomToolbar` - Reusable bottom toolbar for all modals (ðŸŸ¢ map + âš« close buttons)
  - `UserMessageBubble`, `AutoGeneratedTag`

#### **Modal Trigger Logic:**
```kotlin
// "Vedi i dettagli" button opens appropriate modal based on:
message.queryType + message.data (TransitData sealed class)
```

## Next Development Steps

### Immediate Priorities
1. **BOT Message Templates**: Implement the 4 `TransitData` card templates with dual states
2. **Message Compacting UI**: Visual states for `isCompact` true/false
3. **"Vedi i dettagli" Integration**: Connect buttons to `handleModalSelection()`
4. **AUTOGENERATED Removal**: Hide compacted AUTOGENERATED messages from UI
5. **Chat History Flow**: Clean conversation display with only relevant messages

### Future Enhancements
- **API Integration**: Connect to real Turin transport APIs
- **Location Services**: Add GPS-based nearby stop detection
- **Offline Mode**: Cache transit schedules
- **Personalization**: Favorite stops and routes

## Project Structure
```
app/src/main/java/com/av/urbanway/
â”œâ”€â”€ data/
â”‚   â”œâ”€â”€ model/ChatModels.kt          # Core data structures
â”‚   â”œâ”€â”€ repository/ChatRepository.kt  # State management
â”‚   â”œâ”€â”€ service/ChatService.kt       # Business logic
â”‚   â”œâ”€â”€ service/HardcodedDataService.kt # Sample data
â”‚   â””â”€â”€ parser/QueryParser.kt        # NLP processing
â”œâ”€â”€ presentation/
â”‚   â””â”€â”€ navigation/NavigationModels.kt # Navigation state
â”œâ”€â”€ ui/theme/                        # Material 3 theming
â””â”€â”€ MainActivity.kt                  # App entry point
```

## Development Environment
- **IDE**: Android Studio
- **Build System**: Gradle (Kotlin DSL)
- **Version Control**: Git
- **Package**: `com.av.urbanway`

This project represents a modern, user-centric approach to public transport apps, prioritizing natural interaction over complex navigation hierarchies.