# UrbanWay - Turin Public Transport Assistant

![Android CI](https://github.com/YOUR_USERNAME/UrbanWayAndroid/workflows/Android%20CI/badge.svg)
![Release](https://github.com/YOUR_USERNAME/UrbanWayAndroid/workflows/Release%20Build/badge.svg)

## Project Overview

UrbanWay is a **conversational Android app** for Turin's public transport system, built from scratch using modern Android development practices. The app provides an intelligent chat interface that helps users get real-time transport information through natural language queries.

## Architecture & Technology Stack

### Core Technologies
- **Language**: Kotlin
- **UI Framework**: Jetpack Compose (Material 3)
- **Architecture**: MVVM with Repository Pattern
- **Minimum SDK**: 34 (Android 14)
- **Target SDK**: 36 (Latest)

### Key Features Implemented

#### 🤖 Conversational Interface - THE THREE-MESSAGE PATTERN
The app's **core innovation** is a sophisticated three-message conversation pattern:

**1. `USER` Message** - Natural language input
```
"Quali sono le linee che passano vicino a me?"
```

**2. `AUTOGENERATED` Message** - AI interpretation & confirmation
```
"Arrivi nelle vicinanze"
```
- Shows user what the app understood
- Generated by `QueryParser` with context-awareness
- Examples: "Linea 15", "Percorso per il centro città"

**3. `BOT` Message** - Data-rich interactive response
```
"Ho trovato 8 arrivi nelle vicinanze da 5 fermate" + TransitData
```
- Contains actual transit data (`TransitData` sealed classes)
- Interactive UI components (cards, buttons, modals)
- Can be `compact` (summary) or expanded (full details)

**Conversation Flow:**
```
User Input → Parse Query Type → Add AUTOGENERATED → Fetch Data → Add BOT Response
```

#### 🚌 Transit Data Management
Comprehensive data models for Turin's transport system:

**Transport Types Supported:**
- Buses (`BUS`)
- Trams (`TRAM`)
- Metro (`METRO`)
- Trains (`TRAIN`)

**Query Types:**
- `NEARBY` - Find nearby stops and arrivals
- `ROUTEDETAIL` - Get specific route information
- `STOPDETAIL` - View stop details and passing routes
- `JOURNEY` - Plan trips between locations

#### 📊 Real-time Data Integration
- Live arrival times with real-time updates
- Route delays and status information
- Stop locations with coordinates
- Multi-modal transport planning

## Current Implementation Status

### ✅ Completed Components

#### Data Layer (`/data`)
- **Models** (`ChatModels.kt`): Complete data structures for chat messages, transit data, stops, routes, arrivals, **journey planning**
- **Repository** (`ChatRepository.kt`): StateFlow-based message management with automatic cleanup and compacting
- **Services**:
  - `ChatService.kt`: Orchestrates user interactions and data flow for **all 4 query types**
  - `HardcodedDataService.kt`: Provides sample Turin transit data + **journey planning data**
- **Parser** (`QueryParser.kt`): Natural language processing for Italian queries including **journey requests**
- **API Constants** (`ApiJsonConstants.kt`): Real API response JSON for nearby, routes, and **journey planning**

#### UI Layer (`/ui`)
- **Theme System**: Material 3 implementation with dynamic colors
- **Chat Interface** (`ChatScreen.kt`): Complete conversational UI with proper chat bubble styling
- **Bot Cards**: Consistent white card design for **all 4 message types** (Nearby, RouteDetail, StopDetail, **Journey**)
- **Modal System**: Full-screen detail views for **Nearby, RouteDetail, and Journey** with consistent design
- **Input System**: Text field with keyboard dismissal and send functionality
- **MainActivity**: Basic Compose setup with welcome screen

#### Chat Experience Features
- **Message Cleanup System**: Automatic removal of previous user/autogenerated messages except the last one
- **Chat Bubble Styling**: Proper left/right padding for authentic messaging app feel
- **Keyboard Management**: Auto-dismissal when sending messages
- **Card Consistency**: Unified design language across all bot response cards

### ✅ Recently Completed (Journey Feature)
- **Journey Planning**: Complete end-to-end journey planning from Piazza Adriano to Piazza Castello
- **JourneyBotCard**: Compact/expanded states showing route options and timing
- **JourneyModal**: Detailed view with multiple route options, step-by-step navigation, and transport icons
- **Journey Data**: Real API JSON parsing with 5 route options (direct + transfer routes)

### 🚧 Next Development Priorities
- **UI/UX Polish**: Enhanced visual design, animations, and user experience improvements
- **Maps Integration**: Interactive maps for routes, stops, and real-time tracking
- **StopDetail Modal**: Complete stop information with passing routes and schedules
- **API Integration**: Real Turin transit API connection
- **Navigation**: Screen navigation system

## Screenshot Analysis

From the provided screenshot, the intended UI shows:

1. **Header**: "Assistente UrbanWay" with chat conversation count
2. **Chat Interface**: Natural language input ("Quali sono le linee che passano vicino a me?")
3. **Response Cards**:
   - Location-based results (e.g., "Piazza Adriano")
   - Transit information ("15 linee e hai 14 fermate disponibili")
   - Action buttons ("Vedi i dettagli")
4. **Input Field**: Bottom text input for user queries
5. **Dark Theme**: Modern dark UI design

## Key Architectural Decisions

### 1. **Three-Message Conversation Pattern** 🔄
**The fundamental UX innovation**: Every user query triggers exactly 3 messages:
- `USER` → `AUTOGENERATED` → `BOT`
- Creates transparency: users see what the app understood
- Enables progressive disclosure with context preservation

### 2. **Smart Message State Management**
```kotlin
// Message Compacting: Keep chat clean
compactAllPreviousMessages() // Makes BOT messages compact except current

// Modal Interactions: Seamless drilling down
handleModalSelection("Linea 15", QueryType.NEARBY) → New conversation branch
```

### 3. **Query Type State Transitions**
Intelligent navigation between contexts:
```
NEARBY → ROUTEDETAIL → STOPDETAIL → NEARBY (full circle)
JOURNEY → STOPDETAIL (direct context switch)
```

### 4. **Natural Language Processing (Italian)**
`QueryParser` with context-aware interpretation:
- Route extraction: "linea 15" → "Linea 15"
- Location detection: "centro" → "Percorso per il centro città"
- Intent classification: "arrivi" → `QueryType.NEARBY`

### 5. **Reactive UI with Compact/Expand States**
- `isCompact: false` → Full interactive cards with buttons
- `isCompact: true` → Summary view for chat history
- StateFlow-driven UI updates

## Sample Data (Piazza Adriano Area)

The app currently uses hardcoded Turin transit data around **Piazza Adriano**:

**Nearby Stops:**
- Fermata 595 - ADRIANO (Routes: 16CDU, 56U, 9U)
- Fermata 646 - ADRIANO (Routes: 16CSU, 56U, 9U)
- Fermata 3286 - FERRUCCI (Routes: 55U, 68U, 9U)
- Fermata 3287 - FERRUCCI (Routes: 55U, 68U, 9U)
- Fermata 1532 - CAVALLI (Route: 56U)

**Active Routes:**
- Line 16 (Circolare Destra/Sinistra)
- Lines 55, 56, 68, 9 (Various directions)

## Critical Implementation Notes for Development

### 🚨 **MUST UNDERSTAND: The Three-Message Pattern**
When implementing UI components, remember:

1. **`USER` messages**: Chat bubbles on the right with 70dp left padding for proper alignment
2. **`AUTOGENERATED` messages**: System interpretation tags (like "Arrivi nelle vicinanze") on the right
3. **`BOT` messages**: Interactive white cards on the left with 70dp right padding, containing:
   - Transit data rendering (`TransitData` sealed classes)
   - Action buttons that trigger `handleModalSelection()`
   - Compact/expanded states based on `isCompact` boolean

### 🔄 **Message State Lifecycle & Cleanup**
```kotlin
// User sends message → Keyboard auto-dismisses
// New BOT message added → Automatic cleanup triggered:
//   - All previous USER messages removed except the last one
//   - All previous AUTOGENERATED messages removed except current one
//   - Previous BOT messages become compact
// Modal selection → New AUTOGENERATED + BOT pair added
// Query type transitions follow predefined flow
```

### 🎯 **BOT Message Template System - THREE TEMPLATES PER QueryType**

#### **Template States & Compacting Logic:**
```kotlin
// Default: isCompact = false (expanded card)
// When new BOT message added via addBotMessage():
cleanupMessagesAfterBotInsert() {
    - All previous USER messages: REMOVED except the last one
    - All previous AUTOGENERATED messages: REMOVED except current one
    - All previous BOT messages: isCompact = true (compact version)
    - Current BOT message: isCompact = false (expanded + button)
}
```

#### **Three Templates for Each QueryType:**

**For NEARBY, ROUTEDETAIL, STOPDETAIL, JOURNEY - each needs:**

**1. Compact Template** (`isCompact = true`)
```
Brief summary text only - no interactions
```

**2. Expanded Template** (`isCompact = false` - shown in screenshot)
```
🟢 Piazza Adriano                    [Green location pin]
Da qui passano 15 linee e hai 14
fermate disponibili.

           [Vedi i dettagli]         [Centered button]
```

**3. Modal Fullscreen Template** (triggered by "Vedi i dettagli")
```
Full-screen overlay with detailed TransitData
Layout varies by QueryType and data content

STANDARD MODAL STRUCTURE:
├── Header (title + close X button)
├── Content (scrollable LazyColumn)
└── Bottom Toolbar (map + close buttons, centered)
```

#### **Total UI Components: 12 Templates + Shared Components**
- **Chat Cards**: `NearbyBotCard` ✅, `RouteDetailBotCard` ✅, `StopDetailBotCard` ✅, `JourneyBotCard` ✅ (each with compact/expanded states)
- **Fullscreen Modals**: `NearbyModal` ✅, `RouteDetailModal` ✅, `JourneyModal` ✅, `StopDetailModal` (pending)
- **Chat Interface**: `ChatScreen` ✅ with proper padding and keyboard management
- **Shared Components**:
  - `ModalBottomToolbar` ✅ - Reusable bottom toolbar for all modals (🟢 map + ⚫ close buttons)
  - User/Autogenerated message rendering integrated in `ChatScreen` ✅

#### **Modal Trigger Logic:**
```kotlin
// "Vedi i dettagli" button opens appropriate modal based on:
message.queryType + message.data (TransitData sealed class)
```

## Next Development Steps

### Immediate Priorities
1. **UI/UX Polish**: Enhanced animations, transitions, and visual improvements
2. **Maps Integration**: Interactive route visualization and stop locations
3. **Missing Modal**: Complete `StopDetailModal` implementation
4. **Stop Detail Data**: Add real stop detail functionality and JSON parsing

### Recent Completions ✅
- **Journey Feature**: Complete end-to-end journey planning (Piazza Adriano → Piazza Castello)
- **JourneyBotCard**: Compact/expanded states with real data display
- **JourneyModal**: Detailed route options with step-by-step navigation
- **Chat Interface**: Complete conversational UI with proper bubble styling
- **Message Cleanup**: Automatic removal of previous messages for clean chat flow
- **Card Consistency**: All bot cards follow unified white design language
- **API Integration**: Real Turin transport data parsing for all features

### Future Enhancements
- **API Integration**: Connect to real Turin transport APIs
- **Location Services**: Add GPS-based nearby stop detection
- **Offline Mode**: Cache transit schedules
- **Personalization**: Favorite stops and routes

## Project Structure
```
app/src/main/java/com/av/urbanway/
├── data/
│   ├── model/ChatModels.kt          # Core data structures
│   ├── repository/ChatRepository.kt  # State management
│   ├── service/ChatService.kt       # Business logic
│   ├── service/HardcodedDataService.kt # Sample data
│   └── parser/QueryParser.kt        # NLP processing
├── presentation/
│   └── navigation/NavigationModels.kt # Navigation state
├── ui/theme/                        # Material 3 theming
└── MainActivity.kt                  # App entry point
```

## Development Environment
- **IDE**: Android Studio
- **Build System**: Gradle (Kotlin DSL)
- **Version Control**: Git
- **Package**: `com.av.urbanway`

## Chat Experience Design

### 🎨 **Visual Design System**
The app implements an authentic messaging interface with careful attention to chat UX:

- **Message Alignment**: User messages appear on the right, bot messages on the left
- **Padding System**: 70dp strategic padding creates proper visual separation
- **Card Consistency**: All bot responses use unified white cards with rounded corners
- **Typography**: Consistent font weights and sizes across all message types

### 🧹 **Smart Message Management**
Advanced message cleanup system ensures conversations stay focused:

- **Automatic Cleanup**: When bot responds, previous messages are intelligently filtered
- **Context Preservation**: Last user question always visible for conversation continuity
- **History Compacting**: Previous bot responses become compact summaries
- **Clean Flow**: No clutter from multiple conversation threads

### ⌨️ **Input Experience**
Refined text input handling for smooth interactions:

- **Auto-dismiss Keyboard**: Keyboard disappears immediately after sending
- **Send Button Integration**: Clear visual feedback on message transmission
- **Focus Management**: Proper focus handling prevents UI glitches

This project represents a modern, user-centric approach to public transport apps, prioritizing natural interaction over complex navigation hierarchies.